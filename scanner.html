<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script src="https://cdn.tailwindcss.com"></script>
  </head>

  <body>
    <div id="app">
      <div
        class="flex flex-col items-start w-full items-center justify-center align-middle"
      >
        <div class="text-xl my-4">Data Receiver Mode</div>
        <div class="text-sm mb-4">{{user_message}}</div>
        <div class="text-sm mb-4">
          Progress: {{received_chunk_count}} / {{file_metadata.chunks || 0}}
        </div>
        <div class="text-sm mb-2">Missing Chunks: {{missing_chunk_count}}</div>
        <div v-if="file_metadata.file_sha256" class="text-sm mb-2">
          Sender SHA256: {{short_checksum(file_metadata.file_sha256)}}
        </div>
        <div v-if="receiver_file_sha256" class="text-sm mb-2">
          Receiver SHA256: {{short_checksum(receiver_file_sha256)}}
        </div>
        <div v-if="integrity_status" class="text-sm mb-2">
          Integrity: {{integrity_status}}
        </div>
        <div v-if="corrupt_chunk_count > 0" class="text-sm mb-2">
          Corrupt Chunks Rejected: {{corrupt_chunk_count}}
        </div>
        <button
          v-if="!is_receiving"
          v-on:click="start_receiver"
          class="mb-6 p-1 border-2 border-gray-500"
        >
          Start Receiver
        </button>
        <button
          v-else
          v-on:click="stop_receiver"
          class="mb-6 p-1 border-2 border-gray-500"
        >
          Stop Receiver
        </button>
        <div
          v-show="file_metadata.session_id && file_metadata.chunks > 0"
          class="w-3/4 mt-4"
        >
          <button
            v-on:click="generate_retry_code"
            class="mb-2 p-1 border-2 border-gray-500 text-sm"
          >
            Generate Retry Code
          </button>
          <button
            v-if="retry_code"
            v-on:click="copy_retry_code"
            class="mb-2 ml-2 p-1 border-2 border-gray-500 text-sm"
          >
            Copy Retry Code
          </button>
          <div v-if="retry_code" class="text-xs break-all mb-2">{{retry_code}}</div>
        </div>
        <video id="videoElement" muted autoplay playsinline></video>
      </div>
    </div>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@undecaf/zbar-wasm@latest/dist/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.3/pako.min.js"></script>
    <script>
      const { createApp, ref, reactive, computed, onMounted } = Vue;

      const AUTO_SCAN_BASE = {
        scan_interval_ms: 15,
        scan_max_dimension: 720,
        scan_crop_ratio: 1,
        skip_duplicate_payloads: true,
      };
      const RETRY_CODE_EMPTY_PAYLOAD = "OK";
      const SCANNER_RESILIENCE = {
        stall_soft_ms: 4500,
        stall_hard_ms: 12000,
        recovery_cooldown_ms: 3500,
        camera_not_ready_hard_ms: 3000,
      };

      const CRC32_TABLE = (() => {
        const table = new Uint32Array(256);
        for (let i = 0; i < 256; i++) {
          let crc = i;
          for (let j = 0; j < 8; j++) {
            crc = (crc & 1) ? 0xedb88320 ^ (crc >>> 1) : crc >>> 1;
          }
          table[i] = crc >>> 0;
        }
        return table;
      })();

      createApp({
        setup() {
          const user_message = ref("Click receive button to start receiving");
          const received_chunk_count = ref(0);
          const auto_scan_profile = reactive({ ...AUTO_SCAN_BASE });
          const file_metadata = reactive({
            session_id: "",
            name: "",
            chunks: 0,
            compressed_length: 0,
            file_size: 0,
            file_sha256: "",
            sender_profile: "",
          });
          const retry_code = ref("");
          const receiver_file_sha256 = ref("");
          const integrity_status = ref("");
          const corrupt_chunk_count = ref(0);
          const is_receiving = ref(false);
          let canvas, context, videoElement;
          let media_stream = null;
          let last_decoded_payload = "";
          let last_applied_sender_profile = "";
          let chunk_store = [];
          let received_index_set = new Set();
          let scan_source_rect = { x: 0, y: 0, width: 0, height: 0 };

          const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

          const stop_camera_stream = () => {
            if (!media_stream) {
              return;
            }
            for (const track of media_stream.getTracks()) {
              track.stop();
            }
            media_stream = null;
          };

          const attach_camera_stream = async (restart = false) => {
            if (restart) {
              stop_camera_stream();
            }
            if (!media_stream) {
              media_stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: "environment" },
              });
            }
            videoElement.srcObject = media_stream;
            await sleep(250);
          };

          const get_scanner_config = () => {
            return {
              scan_interval_ms: Math.max(
                5,
                Math.floor(auto_scan_profile.scan_interval_ms)
              ),
              scan_max_dimension: Math.max(
                240,
                Math.floor(auto_scan_profile.scan_max_dimension)
              ),
              scan_crop_ratio: Math.min(
                1,
                Math.max(0.2, Number(auto_scan_profile.scan_crop_ratio))
              ),
              skip_duplicate_payloads: Boolean(
                auto_scan_profile.skip_duplicate_payloads
              ),
            };
          };

          const parse_sender_profile = (profile_text) => {
            if (!profile_text) {
              return null;
            }

            const parts = profile_text.split(".");
            if (parts.length !== 4 && parts.length !== 6) {
              return null;
            }

            const values = parts.map((part) => Number.parseInt(part, 36));
            if (values.some((value) => !Number.isFinite(value) || value <= 0)) {
              return null;
            }

            if (parts.length === 4) {
              return {
                frame_interval_ms: values[0],
                start_delay_ms: values[1],
                retry_repeat_count: values[2],
                initial_chunk_size: values[3],
              };
            }

            return {
              frame_interval_ms: values[0],
              start_delay_ms: values[1],
              retry_repeat_count: values[4],
              initial_chunk_size: values[5],
            };
          };

          const apply_sender_profile = (sender_profile_text) => {
            const sender_profile = parse_sender_profile(sender_profile_text);
            if (!sender_profile) {
              auto_scan_profile.scan_interval_ms = AUTO_SCAN_BASE.scan_interval_ms;
              auto_scan_profile.scan_max_dimension = AUTO_SCAN_BASE.scan_max_dimension;
              auto_scan_profile.scan_crop_ratio = AUTO_SCAN_BASE.scan_crop_ratio;
              auto_scan_profile.skip_duplicate_payloads =
                AUTO_SCAN_BASE.skip_duplicate_payloads;
              return;
            }

            const likely_dense_qr = sender_profile.initial_chunk_size >= 320;
            const likely_fast_frames = sender_profile.frame_interval_ms <= 80;

            auto_scan_profile.scan_interval_ms = Math.max(
              7,
              Math.min(25, Math.floor(sender_profile.frame_interval_ms * 0.45))
            );
            auto_scan_profile.scan_max_dimension = likely_dense_qr
              ? 900
              : likely_fast_frames
              ? 820
              : 700;
            auto_scan_profile.scan_crop_ratio = likely_dense_qr
              ? 0.9
              : likely_fast_frames
              ? 0.85
              : 0.8;
            auto_scan_profile.skip_duplicate_payloads = true;
          };

          const configure_scan_canvas = (runtime_config) => {
            const frame_width = videoElement.videoWidth;
            const frame_height = videoElement.videoHeight;

            if (!frame_width || !frame_height) {
              return false;
            }

            const source_width = Math.max(
              1,
              Math.floor(frame_width * runtime_config.scan_crop_ratio)
            );
            const source_height = Math.max(
              1,
              Math.floor(frame_height * runtime_config.scan_crop_ratio)
            );

            scan_source_rect = {
              x: Math.floor((frame_width - source_width) / 2),
              y: Math.floor((frame_height - source_height) / 2),
              width: source_width,
              height: source_height,
            };

            const frame_scale = Math.min(
              1,
              runtime_config.scan_max_dimension /
                Math.max(source_width, source_height)
            );

            canvas.height = Math.max(1, Math.floor(source_height * frame_scale));
            canvas.width = Math.max(1, Math.floor(source_width * frame_scale));
            return true;
          };

          const crc32_bytes = (bytes) => {
            let crc = 0xffffffff;
            for (let i = 0; i < bytes.length; i++) {
              crc = CRC32_TABLE[(crc ^ bytes[i]) & 0xff] ^ (crc >>> 8);
            }
            return (crc ^ 0xffffffff) >>> 0;
          };

          const crc32_text = (value) => {
            return crc32_bytes(new TextEncoder().encode(value));
          };

          const short_checksum = (value) => {
            if (!value) {
              return "-";
            }
            return value.slice(0, 16).toUpperCase();
          };

          const sha256_hex = async (bytes) => {
            if (!window.crypto || !window.crypto.subtle) {
              throw new Error("SHA-256 not available in this browser context");
            }
            const digest = await window.crypto.subtle.digest("SHA-256", bytes);
            const output = Array.from(new Uint8Array(digest));
            return output
              .map((value) => value.toString(16).padStart(2, "0"))
              .join("");
          };

          const base64_to_uint8 = (value) => {
            const binary = atob(value);
            const output = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
              output[i] = binary.charCodeAt(i);
            }
            return output;
          };

          const base64_to_text = (value) => {
            return new TextDecoder().decode(base64_to_uint8(value));
          };

          const parse_metadata_packet = (input_string) => {
            if (!input_string.startsWith("M:")) {
              // Backward compatibility for old metadata payloads.
              if (input_string.startsWith("{")) {
                try {
                  const parsed = JSON.parse(input_string);
                  if (!parsed || !parsed.chunks) {
                    return null;
                  }
                  return {
                    session_id: `legacy-${(crc32_text(
                      `${parsed.name || "transfer.bin"}:${parsed.chunks}`
                    ) & 0xffff)
                      .toString(36)
                      .toUpperCase()}`,
                    chunks: parsed.chunks,
                    name: parsed.name || "transfer.bin",
                    compressed_length: 0,
                    file_size: 0,
                    file_sha256: "",
                    sender_profile: "",
                  };
                } catch (_error) {
                  return null;
                }
              }
              return null;
            }
            const parts = input_string.split(":");
            if (parts.length !== 7 && parts.length !== 8) {
              return null;
            }

            const chunks = Number.parseInt(parts[2], 10);
            const compressed_length = Number.parseInt(parts[3], 10);
            const file_size = Number.parseInt(parts[4], 10);
            if (!Number.isFinite(chunks) || chunks <= 0) {
              return null;
            }

            const has_sender_profile = parts.length === 8;

            return {
              session_id: parts[1],
              chunks,
              name: base64_to_text(has_sender_profile ? parts[7] : parts[6]),
              compressed_length: Number.isFinite(compressed_length)
                ? compressed_length
                : 0,
              file_size: Number.isFinite(file_size) ? file_size : 0,
              file_sha256: parts[5],
              sender_profile: has_sender_profile ? parts[6] : "",
            };
          };

          const parse_data_packet = (input_string) => {
            if (!input_string.startsWith("D:")) {
              // Backward compatibility for old data payloads: "index,base64".
              if (input_string.split(",").length === 2) {
                const parts = input_string.split(",");
                const legacy_index = Number.parseInt(parts[0], 10);
                if (!Number.isFinite(legacy_index) || legacy_index < 0) {
                  return null;
                }
                const legacy_data = base64_to_uint8(parts[1]);
                return {
                  session_id: file_metadata.session_id || "legacy",
                  index: legacy_index,
                  total: file_metadata.chunks || 0,
                  chunk_crc_num: crc32_bytes(legacy_data) >>> 0,
                  data: legacy_data,
                };
              }
              return null;
            }
            const parts = input_string.split(":");
            if (parts.length !== 6) {
              return null;
            }

            const index = Number.parseInt(parts[2], 10);
            const total = Number.parseInt(parts[3], 10);
            const chunk_crc_num = Number.parseInt(parts[4], 16);
            if (!Number.isFinite(index) || !Number.isFinite(total) || total <= 0) {
              return null;
            }
            if (
              !Number.isFinite(chunk_crc_num) ||
              chunk_crc_num < 0 ||
              chunk_crc_num > 0xffffffff
            ) {
              return null;
            }

            return {
              session_id: parts[1],
              index,
              total,
              chunk_crc_num: chunk_crc_num >>> 0,
              data_base64: parts[5],
            };
          };

          const encode_indices_to_ranges = (indices) => {
            if (!indices.length) {
              return RETRY_CODE_EMPTY_PAYLOAD;
            }

            const ordered = Array.from(new Set(indices)).sort((a, b) => a - b);
            const ranges = [];
            let start = ordered[0];
            let previous = ordered[0];

            for (let i = 1; i < ordered.length; i++) {
              const current = ordered[i];
              if (current === previous + 1) {
                previous = current;
                continue;
              }

              ranges.push(
                start === previous
                  ? start.toString(36).toUpperCase()
                  : `${start.toString(36).toUpperCase()}-${previous
                      .toString(36)
                      .toUpperCase()}`
              );
              start = current;
              previous = current;
            }

            ranges.push(
              start === previous
                ? start.toString(36).toUpperCase()
                : `${start.toString(36).toUpperCase()}-${previous
                    .toString(36)
                    .toUpperCase()}`
            );

            return ranges.join(".");
          };

          const build_retry_code = (session_id, indices) => {
            const payload = encode_indices_to_ranges(indices);
            const body = `R2:${session_id}:${payload}`;
            const checksum = (crc32_text(body) & 0xffff)
              .toString(36)
              .toUpperCase()
              .padStart(3, "0");
            return `${body}:${checksum}`;
          };

          const get_missing_indices = () => {
            if (!file_metadata.chunks) {
              return [];
            }

            const output = [];
            for (let i = 0; i < file_metadata.chunks; i++) {
              if (!received_index_set.has(i)) {
                output.push(i);
              }
            }
            return output;
          };

          const missing_chunk_count = computed(() => {
            if (!file_metadata.chunks) {
              return 0;
            }
            return Math.max(0, file_metadata.chunks - received_chunk_count.value);
          });

          const reset_transfer_state = () => {
            chunk_store = [];
            received_index_set = new Set();
            received_chunk_count.value = 0;
            file_metadata.session_id = "";
            file_metadata.name = "";
            file_metadata.chunks = 0;
            file_metadata.compressed_length = 0;
            file_metadata.file_size = 0;
            file_metadata.file_sha256 = "";
            file_metadata.sender_profile = "";
            retry_code.value = "";
            receiver_file_sha256.value = "";
            integrity_status.value = "";
            corrupt_chunk_count.value = 0;
            last_decoded_payload = "";
            last_applied_sender_profile = "";
          };

          const generate_retry_code = () => {
            if (!file_metadata.session_id || !file_metadata.chunks) {
              user_message.value = "No active session yet";
              return;
            }

            retry_code.value = build_retry_code(
              file_metadata.session_id,
              get_missing_indices()
            );
            user_message.value =
              "Share retry code with sender. Sender can resend only missing chunks.";
          };

          const copy_retry_code = async () => {
            if (!retry_code.value) {
              return;
            }

            try {
              await navigator.clipboard.writeText(retry_code.value);
              user_message.value = "Retry code copied";
            } catch (error) {
              console.error(error);
              user_message.value = "Unable to copy. Please copy retry code manually";
            }
          };

          const download_file = (data, fileName) => {
            const blob = new Blob([data]);
            const dummy_element = document.createElement("a");
            const url = URL.createObjectURL(blob);
            dummy_element.href = url;
            dummy_element.download = fileName;
            dummy_element.click();
            URL.revokeObjectURL(url);
          };

          const stop_receiver = () => {
            is_receiving.value = false;
            reset_transfer_state();
            user_message.value = "Click receive button to start receiving";
          };

          const start_receiver = async () => {
            reset_transfer_state();
            is_receiving.value = true;
            let runtime_config = get_scanner_config();

            let last_packet_seen_ts = Date.now();
            let last_new_chunk_ts = Date.now();
            let last_recovery_ts = 0;
            let video_not_ready_since_ts = 0;
            let last_loop_error_log_ts = 0;

            const can_attempt_recovery = (now) => {
              return (
                now - last_recovery_ts >= SCANNER_RESILIENCE.recovery_cooldown_ms
              );
            };

            const apply_soft_recovery = (reason) => {
              last_decoded_payload = "";
              auto_scan_profile.scan_crop_ratio = Math.min(
                1,
                Number(auto_scan_profile.scan_crop_ratio) + 0.08
              );
              auto_scan_profile.scan_interval_ms = Math.min(
                30,
                Number(auto_scan_profile.scan_interval_ms) + 3
              );
              runtime_config = get_scanner_config();
              configure_scan_canvas(runtime_config);
              last_recovery_ts = Date.now();
              user_message.value = `Scanner re-locking (${reason})...`;
            };

            const apply_hard_recovery = async (reason) => {
              user_message.value = `Scanner stalled (${reason}), restarting camera...`;
              last_decoded_payload = "";
              await attach_camera_stream(true);
              runtime_config = get_scanner_config();
              if (!configure_scan_canvas(runtime_config)) {
                throw new Error("Camera did not return a readable frame");
              }
              const recovered_at = Date.now();
              last_packet_seen_ts = recovered_at;
              last_new_chunk_ts = recovered_at;
              last_recovery_ts = recovered_at;
              video_not_ready_since_ts = 0;
            };

            if (!configure_scan_canvas(runtime_config)) {
              try {
                await apply_hard_recovery("camera sync");
              } catch (error) {
                console.error(error);
                user_message.value = "Camera is still initializing. Try again.";
                is_receiving.value = false;
                return;
              }
            }

            while (is_receiving.value) {
              if (
                file_metadata.chunks > 0 &&
                received_chunk_count.value === file_metadata.chunks
              ) {
                break;
              }

              const now = Date.now();

              if (videoElement.readyState < 2) {
                if (!video_not_ready_since_ts) {
                  video_not_ready_since_ts = now;
                }
                if (
                  now - video_not_ready_since_ts >=
                    SCANNER_RESILIENCE.camera_not_ready_hard_ms &&
                  can_attempt_recovery(now)
                ) {
                  try {
                    await apply_hard_recovery("camera frame");
                  } catch (error) {
                    console.error(error);
                    user_message.value =
                      "Camera recovery failed. Restart receiver and retry.";
                    is_receiving.value = false;
                    return;
                  }
                }
                await sleep(120);
                continue;
              }
              video_not_ready_since_ts = 0;

              const has_active_session =
                Boolean(file_metadata.session_id) && file_metadata.chunks > 0;
              if (has_active_session && can_attempt_recovery(now)) {
                const no_packet_ms = now - last_packet_seen_ts;
                const no_progress_ms = now - last_new_chunk_ts;
                if (
                  no_packet_ms >= SCANNER_RESILIENCE.stall_hard_ms &&
                  no_progress_ms >= SCANNER_RESILIENCE.stall_soft_ms
                ) {
                  try {
                    await apply_hard_recovery("no packets");
                  } catch (error) {
                    console.error(error);
                    user_message.value =
                      "Scanner recovery failed. Generate retry code and restart receiver.";
                    is_receiving.value = false;
                    return;
                  }
                  continue;
                }
                if (no_packet_ms >= SCANNER_RESILIENCE.stall_soft_ms) {
                  apply_soft_recovery("no packets");
                  await sleep(180);
                  continue;
                }
              }

              try {
                await sleep(runtime_config.scan_interval_ms);
                context.drawImage(
                  videoElement,
                  scan_source_rect.x,
                  scan_source_rect.y,
                  scan_source_rect.width,
                  scan_source_rect.height,
                  0,
                  0,
                  canvas.width,
                  canvas.height
                );
                const image_data = context.getImageData(
                  0,
                  0,
                  canvas.width,
                  canvas.height
                );
                const symbols = await zbarWasm.scanImageData(image_data);
                if (!symbols || !symbols.length) {
                  continue;
                }

                const decoded_data = symbols[0].decode();
                const packet_seen_ts = Date.now();
                last_packet_seen_ts = packet_seen_ts;
                if (
                  runtime_config.skip_duplicate_payloads &&
                  decoded_data === last_decoded_payload
                ) {
                  continue;
                }
                last_decoded_payload = decoded_data;

                const metadata_packet = parse_metadata_packet(decoded_data);
                if (metadata_packet) {
                  const is_new_session =
                    metadata_packet.session_id !== file_metadata.session_id;
                  const sender_profile_changed =
                    metadata_packet.sender_profile !== last_applied_sender_profile;
                  const metadata_changed =
                    is_new_session ||
                    file_metadata.name !== metadata_packet.name ||
                    file_metadata.chunks !== metadata_packet.chunks ||
                    file_metadata.compressed_length !==
                      metadata_packet.compressed_length ||
                    file_metadata.file_size !== metadata_packet.file_size ||
                    file_metadata.file_sha256 !== metadata_packet.file_sha256 ||
                    file_metadata.sender_profile !== metadata_packet.sender_profile;

                  if (is_new_session) {
                    chunk_store = [];
                    received_index_set = new Set();
                    received_chunk_count.value = 0;
                    retry_code.value = "";
                    receiver_file_sha256.value = "";
                    integrity_status.value = "";
                    corrupt_chunk_count.value = 0;
                    last_new_chunk_ts = packet_seen_ts;
                  }

                  if (metadata_changed) {
                    file_metadata.session_id = metadata_packet.session_id;
                    file_metadata.name = metadata_packet.name;
                    file_metadata.chunks = metadata_packet.chunks;
                    file_metadata.compressed_length =
                      metadata_packet.compressed_length;
                    file_metadata.file_size = metadata_packet.file_size;
                    file_metadata.file_sha256 = metadata_packet.file_sha256;
                    file_metadata.sender_profile = metadata_packet.sender_profile;
                    user_message.value = `Transferring file: ${file_metadata.name}`;
                  }

                  if (is_new_session || sender_profile_changed) {
                    apply_sender_profile(metadata_packet.sender_profile);
                    runtime_config = get_scanner_config();
                    configure_scan_canvas(runtime_config);
                    last_applied_sender_profile = metadata_packet.sender_profile;
                  }

                  continue;
                }

                const data_packet = parse_data_packet(decoded_data);
                if (!data_packet) {
                  continue;
                }

                if (!file_metadata.session_id) {
                  file_metadata.session_id = data_packet.session_id;
                  file_metadata.chunks = data_packet.total;
                  file_metadata.name = `transfer-${data_packet.session_id}.bin`;
                  user_message.value = `Transferring file: ${file_metadata.name}`;
                }

                if (
                  data_packet.session_id !== file_metadata.session_id ||
                  data_packet.total !== file_metadata.chunks ||
                  data_packet.index < 0 ||
                  data_packet.index >= file_metadata.chunks
                ) {
                  continue;
                }

                if (received_index_set.has(data_packet.index)) {
                  continue;
                }

                const chunk_data = data_packet.data
                  ? data_packet.data
                  : base64_to_uint8(data_packet.data_base64);

                const computed_crc = crc32_bytes(chunk_data) >>> 0;
                if (computed_crc !== data_packet.chunk_crc_num) {
                  corrupt_chunk_count.value += 1;
                  continue;
                }

                received_index_set.add(data_packet.index);
                chunk_store[data_packet.index] = chunk_data;
                received_chunk_count.value = received_index_set.size;
                last_new_chunk_ts = packet_seen_ts;
              } catch (error) {
                const log_now = Date.now();
                if (log_now - last_loop_error_log_ts > 2000) {
                  console.error("Error in Loop: ", error);
                  last_loop_error_log_ts = log_now;
                }
              }
            }

            if (!is_receiving.value) {
              return true;
            }

            user_message.value = "Data Transfer Complete";

            let total_output_size = 0;
            for (let i = 0; i < file_metadata.chunks; i++) {
              const chunk = chunk_store[i];
              if (!chunk) {
                user_message.value = "Transfer failed: Missing data chunks";
                stop_receiver();
                return;
              }
              total_output_size += chunk.length;
            }

            const compressed_output = new Uint8Array(total_output_size);
            let offset = 0;
            for (let i = 0; i < file_metadata.chunks; i++) {
              const chunk = chunk_store[i];
              compressed_output.set(chunk, offset);
              offset += chunk.length;
            }

            try {
              const inflated_array = pako.inflate(compressed_output);
              receiver_file_sha256.value = await sha256_hex(inflated_array);

              if (
                file_metadata.file_sha256 &&
                receiver_file_sha256.value !== file_metadata.file_sha256
              ) {
                integrity_status.value = "MISMATCH";
                user_message.value =
                  "Integrity mismatch. Generate retry code and request retransmit.";
                const full_retransmit_indices = Array.from(
                  { length: file_metadata.chunks },
                  (_, index) => index
                );
                retry_code.value = build_retry_code(
                  file_metadata.session_id,
                  full_retransmit_indices
                );
                is_receiving.value = false;
                return;
              }

              integrity_status.value = "MATCH";
              retry_code.value = build_retry_code(
                file_metadata.session_id,
                []
              );
              download_file(inflated_array, file_metadata.name);
              user_message.value = "Transfer complete with verified integrity";
            } catch (error) {
              console.error(error);
              user_message.value = "Transfer failed: Unable to unpack data";
              stop_receiver();
              return;
            }

            is_receiving.value = false;
          };

          onMounted(async () => {
            console.log("Application Initialized ...");
            videoElement = document.getElementById("videoElement");
            await attach_camera_stream();
            canvas = document.createElement("canvas");
            context = canvas.getContext("2d", { willReadFrequently: true });
            await sleep(800);
            const runtime_config = get_scanner_config();
            if (configure_scan_canvas(runtime_config)) {
              context.drawImage(
                videoElement,
                scan_source_rect.x,
                scan_source_rect.y,
                scan_source_rect.width,
                scan_source_rect.height,
                0,
                0,
                canvas.width,
                canvas.height
              );
            }

            document.addEventListener("visibilitychange", async () => {
              if (document.hidden || !is_receiving.value) {
                return;
              }
              try {
                await attach_camera_stream(true);
                const refreshed_runtime_config = get_scanner_config();
                configure_scan_canvas(refreshed_runtime_config);
              } catch (error) {
                console.error("Visibility recovery failed:", error);
              }
            });
          });

          return {
            user_message,
            start_receiver,
            is_receiving,
            file_metadata,
            received_chunk_count,
            stop_receiver,
            generate_retry_code,
            copy_retry_code,
            retry_code,
            receiver_file_sha256,
            integrity_status,
            missing_chunk_count,
            corrupt_chunk_count,
            short_checksum,
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
