<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script src="https://cdn.tailwindcss.com"></script>
  </head>

  <body>
    <div id="app">
      <div
        class="flex flex-col items-start w-full items-center justify-center align-middle"
      >
        <div class="text-xl my-4">Data Sender Mode</div>
        <div class="text-sm mb-4">{{user_message}}</div>
        <div v-if="transfer_summary.ready" class="text-sm mb-4">
          Session: {{transfer_summary.session_id}} | Chunks:
          {{transfer_summary.total_chunks}} | SHA256:
          {{short_checksum(transfer_summary.file_sha256)}}
        </div>
        <div v-show="!is_transferring" class="w-1/2 mb-4">
          <input
            class="block w-full text-sm text-gray-900 border border-gray-300 cursor-pointer bg-gray-50 focus:outline-none"
            id="file_input"
            type="file"
          />
        </div>
        <div
          v-show="!is_transferring"
          class="w-3/4 mb-4 text-sm border border-gray-300 p-2"
        >
          <div class="font-semibold mb-2">Sender Preset</div>
          <label>
            Profile
            <select
              v-model="selected_preset"
              class="block w-full border border-gray-300 px-1"
            >
              <option v-for="name in preset_names" :key="name" :value="name">
                {{name}}
              </option>
            </select>
          </label>
          <div class="mt-2 text-xs">{{preset_summary}}</div>
        </div>
        <button
          v-if="!is_transferring"
          v-on:click="start_transfer"
          class="mb-6 p-1 border-2 border-gray-500"
        >
          Start Transfer
        </button>
        <button
          v-else
          v-on:click="stop_transfer"
          class="mb-6 p-1 border-2 border-gray-500"
        >
          Stop Transfer
        </button>
        <div
          v-if="transfer_summary.ready && !is_transferring"
          class="w-3/4 mb-4 text-sm"
        >
          <div class="mb-2">Paste retry code from receiver:</div>
          <input
            v-model.trim="retry_code_input"
            class="block w-full text-sm text-gray-900 border border-gray-300 px-2 py-1 mb-2"
            type="text"
            placeholder="R2:session:missing-ranges:crc"
          />
          <button
            v-on:click="retry_missing_chunks"
            class="p-1 border-2 border-gray-500"
          >
            Resend Missing Chunks
          </button>
          <div
            v-if="retry_feedback"
            class="mt-2 text-xs"
            :class="retry_feedback_is_error ? 'text-red-700' : 'text-green-700'"
          >
            {{retry_feedback}}
          </div>
        </div>
        <div id="qrcode" class=""></div>
        <div
          v-if="is_transferring && transfer_progress.expected_packets > 0"
          class="fixed top-2 left-2 bg-white/90 border border-gray-400 px-3 py-2 text-xs z-50 pointer-events-none"
        >
          <div>
            {{transfer_progress.phase}} {{transfer_progress_percent}}% | Packet
            {{transfer_progress.sent_packets}}/{{transfer_progress.expected_packets}}
          </div>
          <div>
            Round {{transfer_progress.current_round}}/{{transfer_progress.total_rounds}}
            | Chunk {{transfer_progress.current_chunk}}/{{transfer_progress.total_chunks}}
          </div>
        </div>
        <div style="height: 35vh"></div>
      </div>
    </div>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.3/pako.min.js"></script>
    <script>
      const { createApp, ref, reactive, computed, onMounted, nextTick, watch } =
        Vue;

      // Edit this object to fine-tune transfer presets.
      const SENDER_PRESETS = {
        Fast: {
          initial_chunk_size: 360,
          min_chunk_size: 90,
          chunk_safety_ratio: 0.9,
          large_transfer_chunk_threshold: 700,
          large_transfer_repeat_boost: 1,
          very_large_transfer_chunk_threshold: 1000,
          very_large_transfer_repeat_boost: 1,
          max_initial_pass_repeat_count: 4,
          frame_interval_ms: 65,
          start_delay_ms: 500,
          compression_level: 2,
          metadata_repeat_count: 3,
          metadata_heartbeat_interval: 140,
          initial_pass_repeat_count: 2,
          retry_repeat_count: 2,
          retry_high_loss_threshold: 0.14,
          retry_high_loss_frame_multiplier: 1.2,
          retry_high_loss_start_delay_multiplier: 1.15,
          retry_high_loss_metadata_extra: 1,
          retry_high_loss_repeat_increment: 1,
        },
        Aggressive: {
          initial_chunk_size: 440,
          min_chunk_size: 100,
          chunk_safety_ratio: 0.84,
          large_transfer_chunk_threshold: 620,
          large_transfer_repeat_boost: 1,
          very_large_transfer_chunk_threshold: 900,
          very_large_transfer_repeat_boost: 1,
          max_initial_pass_repeat_count: 4,
          frame_interval_ms: 52,
          start_delay_ms: 360,
          compression_level: 1,
          metadata_repeat_count: 2,
          metadata_heartbeat_interval: 120,
          initial_pass_repeat_count: 1,
          retry_repeat_count: 2,
          retry_high_loss_threshold: 0.1,
          retry_high_loss_frame_multiplier: 1.3,
          retry_high_loss_start_delay_multiplier: 1.2,
          retry_high_loss_metadata_extra: 1,
          retry_high_loss_repeat_increment: 1,
        },
        Extreme: {
          initial_chunk_size: 560,
          min_chunk_size: 120,
          chunk_safety_ratio: 0.86,
          large_transfer_chunk_threshold: 560,
          large_transfer_repeat_boost: 1,
          very_large_transfer_chunk_threshold: 820,
          very_large_transfer_repeat_boost: 1,
          max_initial_pass_repeat_count: 4,
          frame_interval_ms: 46,
          start_delay_ms: 240,
          compression_level: 0,
          metadata_repeat_count: 3,
          metadata_heartbeat_interval: 100,
          initial_pass_repeat_count: 1,
          retry_repeat_count: 2,
          retry_high_loss_threshold: 0.08,
          retry_high_loss_frame_multiplier: 1.55,
          retry_high_loss_start_delay_multiplier: 1.25,
          retry_high_loss_metadata_extra: 2,
          retry_high_loss_repeat_increment: 2,
        },
        Balanced: {
          initial_chunk_size: 300,
          min_chunk_size: 80,
          chunk_safety_ratio: 0.92,
          large_transfer_chunk_threshold: 900,
          large_transfer_repeat_boost: 1,
          very_large_transfer_chunk_threshold: 1300,
          very_large_transfer_repeat_boost: 1,
          max_initial_pass_repeat_count: 4,
          frame_interval_ms: 95,
          start_delay_ms: 700,
          compression_level: 3,
          metadata_repeat_count: 4,
          metadata_heartbeat_interval: 180,
          initial_pass_repeat_count: 3,
          retry_repeat_count: 2,
          retry_high_loss_threshold: 0.15,
          retry_high_loss_frame_multiplier: 1.2,
          retry_high_loss_start_delay_multiplier: 1.1,
          retry_high_loss_metadata_extra: 1,
          retry_high_loss_repeat_increment: 1,
        },
        Reliable: {
          initial_chunk_size: 240,
          min_chunk_size: 80,
          chunk_safety_ratio: 0.95,
          large_transfer_chunk_threshold: 1000,
          large_transfer_repeat_boost: 1,
          very_large_transfer_chunk_threshold: 1500,
          very_large_transfer_repeat_boost: 1,
          max_initial_pass_repeat_count: 5,
          frame_interval_ms: 120,
          start_delay_ms: 900,
          compression_level: 4,
          metadata_repeat_count: 5,
          metadata_heartbeat_interval: 220,
          initial_pass_repeat_count: 3,
          retry_repeat_count: 3,
          retry_high_loss_threshold: 0.18,
          retry_high_loss_frame_multiplier: 1.1,
          retry_high_loss_start_delay_multiplier: 1.05,
          retry_high_loss_metadata_extra: 1,
          retry_high_loss_repeat_increment: 1,
        },
      };
      const DEFAULT_PRESET_NAME = "Balanced";
      const RETRY_CODE_EMPTY_PAYLOAD = "OK";

      const CRC32_TABLE = (() => {
        const table = new Uint32Array(256);
        for (let i = 0; i < 256; i++) {
          let crc = i;
          for (let j = 0; j < 8; j++) {
            crc = (crc & 1) ? 0xedb88320 ^ (crc >>> 1) : crc >>> 1;
          }
          table[i] = crc >>> 0;
        }
        return table;
      })();

      createApp({
        setup() {
          const user_message = ref("Choose file to get started");
          const is_transferring = ref(false);
          const retry_code_input = ref("");
          const retry_feedback = ref("");
          const retry_feedback_is_error = ref(false);
          const selected_preset = ref(DEFAULT_PRESET_NAME);
          const preset_names = Object.keys(SENDER_PRESETS);
          const transfer_summary = reactive({
            ready: false,
            session_id: "",
            file_name: "",
            total_chunks: 0,
            file_size: 0,
            file_sha256: "",
          });
          const transfer_progress = reactive({
            phase: "Idle",
            current_chunk: 0,
            total_chunks: 0,
            current_round: 0,
            total_rounds: 0,
            sent_packets: 0,
            expected_packets: 0,
          });
          let qrcode_object = "";
          let current_qr_payload = "Choose file to get started";
          let current_qr_size = 0;
          let active_transfer = null;

          const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

          const fit_qr_to_viewport = (scroll_to_center = false) => {
            const qrcode_element = document.getElementById("qrcode");
            if (!qrcode_element) {
              return;
            }

            const viewport_padding = 12;
            const rect = qrcode_element.getBoundingClientRect();
            const available_height = Math.floor(
              window.innerHeight - rect.top - viewport_padding
            );
            const available_width = Math.floor(
              window.innerWidth - viewport_padding * 2
            );
            const target_size = Math.max(
              1,
              Math.min(available_height, available_width)
            );

            if (!qrcode_object || target_size !== current_qr_size) {
              current_qr_size = target_size;
              qrcode_element.innerHTML = "";
              qrcode_object = new QRCode("qrcode", {
                text: current_qr_payload,
                width: target_size,
                height: target_size,
                typeNumber: 40,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.M,
              });
            }

            if (scroll_to_center) {
              qrcode_element.scrollIntoView({ block: "center", behavior: "auto" });
            }
          };

          const show_qr_payload = (payload) => {
            if (!qrcode_object) {
              fit_qr_to_viewport(false);
            }
            current_qr_payload = payload;
            qrcode_object.clear();
            qrcode_object.makeCode(payload);
          };

          const set_pointer_visibility = (hidden) => {
            const cursor_style = hidden ? "none" : "";
            document.body.style.cursor = cursor_style;
            document.documentElement.style.cursor = cursor_style;
          };

          const get_sender_config = () => {
            const selected_profile =
              SENDER_PRESETS[selected_preset.value] ||
              SENDER_PRESETS[DEFAULT_PRESET_NAME];

            const initial_chunk_size = Math.floor(
              Math.max(
                80,
                Number(selected_profile.initial_chunk_size) ||
                  SENDER_PRESETS[DEFAULT_PRESET_NAME].initial_chunk_size
              )
            );
            const min_chunk_size = Math.floor(
              Math.max(
                40,
                Number(selected_profile.min_chunk_size) ||
                  SENDER_PRESETS[DEFAULT_PRESET_NAME].min_chunk_size
              )
            );

            return {
              initial_chunk_size,
              min_chunk_size: Math.min(min_chunk_size, initial_chunk_size),
              chunk_safety_ratio: Math.min(
                0.98,
                Math.max(
                  0.6,
                  Number(selected_profile.chunk_safety_ratio) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME].chunk_safety_ratio
                )
              ),
              large_transfer_chunk_threshold: Math.floor(
                Math.max(
                  1,
                  Number(selected_profile.large_transfer_chunk_threshold) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME]
                      .large_transfer_chunk_threshold
                )
              ),
              large_transfer_repeat_boost: Math.floor(
                Math.max(
                  0,
                  Number(selected_profile.large_transfer_repeat_boost) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME].large_transfer_repeat_boost
                )
              ),
              very_large_transfer_chunk_threshold: Math.floor(
                Math.max(
                  1,
                  Number(selected_profile.very_large_transfer_chunk_threshold) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME]
                      .very_large_transfer_chunk_threshold
                )
              ),
              very_large_transfer_repeat_boost: Math.floor(
                Math.max(
                  0,
                  Number(selected_profile.very_large_transfer_repeat_boost) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME]
                      .very_large_transfer_repeat_boost
                )
              ),
              max_initial_pass_repeat_count: Math.floor(
                Math.max(
                  1,
                  Number(selected_profile.max_initial_pass_repeat_count) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME]
                      .max_initial_pass_repeat_count
                )
              ),
              frame_interval_ms: Math.floor(
                Math.max(
                  20,
                  Number(selected_profile.frame_interval_ms) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME].frame_interval_ms
                )
              ),
              start_delay_ms: Math.floor(
                Math.max(
                  0,
                  Number(selected_profile.start_delay_ms) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME].start_delay_ms
                )
              ),
              compression_level: Math.floor(
                Math.min(
                  9,
                  Math.max(
                    0,
                    Number(selected_profile.compression_level) ||
                      SENDER_PRESETS[DEFAULT_PRESET_NAME].compression_level
                  )
                )
              ),
              metadata_repeat_count: Math.floor(
                Math.max(
                  1,
                  Number(selected_profile.metadata_repeat_count) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME].metadata_repeat_count
                )
              ),
              metadata_heartbeat_interval: Math.floor(
                Math.max(
                  0,
                  Number(selected_profile.metadata_heartbeat_interval) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME]
                      .metadata_heartbeat_interval
                )
              ),
              initial_pass_repeat_count: Math.floor(
                Math.max(
                  1,
                  Number(selected_profile.initial_pass_repeat_count) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME].initial_pass_repeat_count
                )
              ),
              retry_repeat_count: Math.floor(
                Math.max(
                  1,
                  Number(selected_profile.retry_repeat_count) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME].retry_repeat_count
                )
              ),
              retry_high_loss_threshold: Math.min(
                0.5,
                Math.max(
                  0,
                  Number(selected_profile.retry_high_loss_threshold) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME].retry_high_loss_threshold
                )
              ),
              retry_high_loss_frame_multiplier: Math.max(
                1,
                Number(selected_profile.retry_high_loss_frame_multiplier) ||
                  SENDER_PRESETS[DEFAULT_PRESET_NAME]
                    .retry_high_loss_frame_multiplier
              ),
              retry_high_loss_start_delay_multiplier: Math.max(
                1,
                Number(selected_profile.retry_high_loss_start_delay_multiplier) ||
                  SENDER_PRESETS[DEFAULT_PRESET_NAME]
                    .retry_high_loss_start_delay_multiplier
              ),
              retry_high_loss_metadata_extra: Math.floor(
                Math.max(
                  0,
                  Number(selected_profile.retry_high_loss_metadata_extra) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME]
                      .retry_high_loss_metadata_extra
                )
              ),
              retry_high_loss_repeat_increment: Math.floor(
                Math.max(
                  0,
                  Number(selected_profile.retry_high_loss_repeat_increment) ||
                    SENDER_PRESETS[DEFAULT_PRESET_NAME]
                      .retry_high_loss_repeat_increment
                )
              ),
            };
          };

          const preset_summary = computed(() => {
            const config = get_sender_config();
            return `chunk=${config.initial_chunk_size}, safe=${Math.round(
              config.chunk_safety_ratio * 100
            )}%, frame=${config.frame_interval_ms}ms, start=${config.start_delay_ms}ms, comp=${config.compression_level}, meta=${config.metadata_repeat_count}, hb=${config.metadata_heartbeat_interval}, init=${config.initial_pass_repeat_count}, retry=${config.retry_repeat_count}`;
          });

          const transfer_progress_percent = computed(() => {
            if (!transfer_progress.expected_packets) {
              return 0;
            }
            return Math.min(
              100,
              Math.floor(
                (transfer_progress.sent_packets / transfer_progress.expected_packets) *
                  100
              )
            );
          });

          const get_initial_pass_repeat_count = (runtime_config, total_chunks) => {
            let repeats = runtime_config.initial_pass_repeat_count;
            if (total_chunks >= runtime_config.large_transfer_chunk_threshold) {
              repeats += runtime_config.large_transfer_repeat_boost;
            }
            if (total_chunks >= runtime_config.very_large_transfer_chunk_threshold) {
              repeats += runtime_config.very_large_transfer_repeat_boost;
            }
            return Math.min(runtime_config.max_initial_pass_repeat_count, repeats);
          };

          const crc32_bytes = (bytes) => {
            let crc = 0xffffffff;
            for (let i = 0; i < bytes.length; i++) {
              crc = CRC32_TABLE[(crc ^ bytes[i]) & 0xff] ^ (crc >>> 8);
            }
            return (crc ^ 0xffffffff) >>> 0;
          };

          const crc32_text = (value) => {
            return crc32_bytes(new TextEncoder().encode(value));
          };

          const short_checksum = (value) => {
            if (!value) {
              return "-";
            }
            return value.slice(0, 16).toUpperCase();
          };

          const sha256_hex = async (bytes) => {
            if (!window.crypto || !window.crypto.subtle) {
              throw new Error("SHA-256 not available in this browser context");
            }
            const digest = await window.crypto.subtle.digest("SHA-256", bytes);
            const output = Array.from(new Uint8Array(digest));
            return output
              .map((value) => value.toString(16).padStart(2, "0"))
              .join("");
          };

          const uint8_to_base64 = (bytes) => {
            let binary = "";
            const batch_size = 0x8000;
            for (let i = 0; i < bytes.length; i += batch_size) {
              binary += String.fromCharCode.apply(
                null,
                bytes.subarray(i, i + batch_size)
              );
            }
            return btoa(binary);
          };

          const text_to_base64 = (value) => {
            const encoded = new TextEncoder().encode(value);
            return uint8_to_base64(encoded);
          };

          const create_retry_code_error = (reason, message) => {
            const error = new Error(message);
            error.retry_code_reason = reason;
            return error;
          };

          const format_retry_code_error = (error) => {
            if (!error || !error.retry_code_reason) {
              return `Invalid retry code: ${error && error.message ? error.message : "Unknown error"}`;
            }

            if (error.retry_code_reason === "format_invalid") {
              return "Invalid retry code format. Expected R2:session:ranges:crc.";
            }
            if (error.retry_code_reason === "checksum_mismatch") {
              return "Retry code checksum mismatch. Re-copy it from scanner.";
            }
            if (error.retry_code_reason === "range_invalid") {
              return "Retry code contains invalid missing ranges.";
            }
            if (error.retry_code_reason === "chunk_total_invalid") {
              return "Retry code contains invalid chunk total.";
            }
            if (error.retry_code_reason === "session_mismatch") {
              return "Retry code belongs to a different transfer session.";
            }
            if (error.retry_code_reason === "chunk_count_mismatch") {
              return "Retry code chunk count does not match current transfer.";
            }

            return `Invalid retry code: ${error.message}`;
          };

          const encode_indices_to_ranges = (indices) => {
            if (!indices.length) {
              return RETRY_CODE_EMPTY_PAYLOAD;
            }

            const ordered = Array.from(new Set(indices)).sort((a, b) => a - b);
            const ranges = [];
            let start = ordered[0];
            let previous = ordered[0];

            for (let i = 1; i < ordered.length; i++) {
              const current = ordered[i];
              if (current === previous + 1) {
                previous = current;
                continue;
              }

              ranges.push(
                start === previous
                  ? start.toString(36).toUpperCase()
                  : `${start.toString(36).toUpperCase()}-${previous
                      .toString(36)
                      .toUpperCase()}`
              );
              start = current;
              previous = current;
            }

            ranges.push(
              start === previous
                ? start.toString(36).toUpperCase()
                : `${start.toString(36).toUpperCase()}-${previous
                    .toString(36)
                    .toUpperCase()}`
            );

            return ranges.join(".");
          };

          const decode_ranges_to_indices = (payload, total_chunks) => {
            if (payload === RETRY_CODE_EMPTY_PAYLOAD || payload === "NONE") {
              return [];
            }

            const output = [];
            const segments = payload.split(".");

            for (const segment of segments) {
              if (!segment) {
                continue;
              }

              if (segment.includes("-")) {
                const [start_text, end_text] = segment.split("-");
                const start = Number.parseInt(start_text, 36);
                const end = Number.parseInt(end_text, 36);
                if (
                  !Number.isFinite(start) ||
                  !Number.isFinite(end) ||
                  start < 0 ||
                  end < start
                ) {
                  throw create_retry_code_error(
                    "range_invalid",
                    "Retry code contains invalid range"
                  );
                }

                for (let value = start; value <= end; value++) {
                  if (!total_chunks || value < total_chunks) {
                    output.push(value);
                  }
                }
              } else {
                const single = Number.parseInt(segment, 36);
                if (!Number.isFinite(single) || single < 0) {
                  throw create_retry_code_error(
                    "range_invalid",
                    "Retry code contains invalid index"
                  );
                }
                if (!total_chunks || single < total_chunks) {
                  output.push(single);
                }
              }
            }

            return Array.from(new Set(output)).sort((a, b) => a - b);
          };

          const build_retry_code = (session_id, indices) => {
            const payload = encode_indices_to_ranges(indices);
            const body = `R2:${session_id}:${payload}`;
            const checksum = (crc32_text(body) & 0xffff)
              .toString(36)
              .toUpperCase()
              .padStart(3, "0");
            return `${body}:${checksum}`;
          };

          const parse_retry_code = (input_code, expected_total_chunks = 0) => {
            const parts = input_code.trim().split(":");
            const retry_version = (parts[0] || "").toUpperCase();

            if (retry_version === "R2") {
              if (parts.length !== 4) {
                throw create_retry_code_error(
                  "format_invalid",
                  "Retry code format is invalid"
                );
              }
              if (!parts[1]) {
                throw create_retry_code_error(
                  "format_invalid",
                  "Retry code session is missing"
                );
              }
              const body = parts.slice(0, 3).join(":");
              const provided_checksum = parts[3].toUpperCase();
              const expected_checksum = (crc32_text(body) & 0xffff)
                .toString(36)
                .toUpperCase()
                .padStart(3, "0");
              if (provided_checksum !== expected_checksum) {
                throw create_retry_code_error(
                  "checksum_mismatch",
                  "Retry code checksum mismatch"
                );
              }
              return {
                session_id: parts[1],
                total_chunks: expected_total_chunks,
                indices: decode_ranges_to_indices(parts[2], expected_total_chunks),
              };
            }

            if (retry_version === "R1") {
              if (parts.length !== 5) {
                throw create_retry_code_error(
                  "format_invalid",
                  "Retry code format is invalid"
                );
              }
              if (!parts[1]) {
                throw create_retry_code_error(
                  "format_invalid",
                  "Retry code session is missing"
                );
              }
              const body = parts.slice(0, 4).join(":");
              const provided_checksum = parts[4].toUpperCase();
              const expected_checksum = (crc32_text(body) & 0xffff)
                .toString(36)
                .toUpperCase()
                .padStart(3, "0");
              if (provided_checksum !== expected_checksum) {
                throw create_retry_code_error(
                  "checksum_mismatch",
                  "Retry code checksum mismatch"
                );
              }

              const total_chunks = Number.parseInt(parts[2], 10);
              if (!Number.isFinite(total_chunks) || total_chunks <= 0) {
                throw create_retry_code_error(
                  "chunk_total_invalid",
                  "Retry code total chunk count is invalid"
                );
              }

              return {
                session_id: parts[1],
                total_chunks,
                indices: decode_ranges_to_indices(parts[3], total_chunks),
              };
            }

            throw create_retry_code_error(
              "format_invalid",
              "Retry code format is invalid"
            );
          };

          const build_metadata_packet = (
            session_id,
            file_name,
            total_chunks,
            compressed_length,
            file_size,
            file_sha256,
            sender_profile
          ) => {
            return `M:${session_id}:${total_chunks}:${compressed_length}:${file_size}:${file_sha256}:${sender_profile}:${text_to_base64(
              file_name
            )}`;
          };

          const build_sender_profile = (runtime_config) => {
            return [
              runtime_config.frame_interval_ms,
              runtime_config.start_delay_ms,
              runtime_config.metadata_repeat_count,
              runtime_config.initial_pass_repeat_count,
              runtime_config.retry_repeat_count,
              runtime_config.initial_chunk_size,
            ]
              .map((value) => value.toString(36))
              .join(".");
          };

          const build_data_packet = (
            session_id,
            index,
            total_chunks,
            input_bytes,
            chunk_crc
          ) => {
            return `D:${session_id}:${index}:${total_chunks}:${chunk_crc}:${uint8_to_base64(
              input_bytes
            )}`;
          };

          const can_fit_in_qr = (packet) => {
            if (!qrcode_object) {
              fit_qr_to_viewport(false);
            }
            try {
              qrcode_object.makeCode(packet);
              return true;
            } catch (error) {
              if (
                error &&
                typeof error.message === "string" &&
                error.message.includes("code length overflow")
              ) {
                return false;
              }
              throw error;
            }
          };

          const get_chunk_packet = (index) => {
            const start = index * active_transfer.chunk_size;
            const chunk = active_transfer.compressed_data.subarray(
              start,
              start + active_transfer.chunk_size
            );
            let chunk_crc = active_transfer.chunk_crc_map[index];
            if (!chunk_crc) {
              chunk_crc = crc32_bytes(chunk)
                .toString(16)
                .toUpperCase()
                .padStart(8, "0");
              active_transfer.chunk_crc_map[index] = chunk_crc;
            }

            return build_data_packet(
              active_transfer.session_id,
              index,
              active_transfer.total_chunks,
              chunk,
              chunk_crc
            );
          };

          const send_chunk_indices = async (
            chunk_indices,
            repeat_count,
            phase_label,
            runtime_config
          ) => {
            if (!active_transfer || !chunk_indices.length) {
              return;
            }

            is_transferring.value = true;
            await nextTick();
            fit_qr_to_viewport(true);

            for (let i = 0; i < runtime_config.metadata_repeat_count; i++) {
              show_qr_payload(active_transfer.metadata_packet);
              await sleep(runtime_config.frame_interval_ms);
            }

            await sleep(runtime_config.start_delay_ms);

            let sent_count = 0;
            const rounds = Math.max(1, Math.floor(repeat_count));
            transfer_progress.phase = phase_label;
            transfer_progress.current_chunk = 0;
            transfer_progress.total_chunks = active_transfer.total_chunks;
            transfer_progress.current_round = 1;
            transfer_progress.total_rounds = rounds;
            transfer_progress.sent_packets = 0;
            transfer_progress.expected_packets = chunk_indices.length * rounds;

            outer_loop: for (let round = 0; round < rounds; round++) {
              for (let i = 0; i < chunk_indices.length; i++) {
                const chunk_index = chunk_indices[i];
                const packet = get_chunk_packet(chunk_index);
                if (!is_transferring.value) {
                  break outer_loop;
                }

                show_qr_payload(packet);
                sent_count += 1;
                transfer_progress.current_round = round + 1;
                transfer_progress.current_chunk = chunk_index + 1;
                transfer_progress.sent_packets = sent_count;
                if (
                  runtime_config.metadata_heartbeat_interval > 0 &&
                  sent_count % runtime_config.metadata_heartbeat_interval === 0
                ) {
                  show_qr_payload(active_transfer.metadata_packet);
                  await sleep(runtime_config.frame_interval_ms);
                }
                user_message.value = `${phase_label} round ${round + 1}/${rounds} chunk ${
                  chunk_index + 1
                }/${active_transfer.total_chunks} (${i + 1}/${chunk_indices.length})`;
                await sleep(runtime_config.frame_interval_ms);
              }
            }

            is_transferring.value = false;
            if (sent_count > 0) {
              transfer_progress.phase = `${phase_label} done`;
              const expected_retry = build_retry_code(
                active_transfer.session_id,
                []
              );
              user_message.value =
                "Pass finished. Use receiver retry code for missing chunks. If complete, receiver should show integrity match.";
              if (retry_code_input.value === expected_retry) {
                retry_code_input.value = "";
              }
            }
          };

          const stop_transfer = () => {
            is_transferring.value = false;
            transfer_progress.phase = "Paused";
            retry_feedback.value = "";
            user_message.value = transfer_summary.ready
              ? "Transfer paused. Paste retry code to continue."
              : "Choose file to get started";
          };

          const start_transfer = async () => {
            const file_input = document.getElementById("file_input");
            const file = file_input.files[0];
            const runtime_config = get_sender_config();

            if (!file) {
              user_message.value = "Choose a file before starting transfer";
              return;
            }

            is_transferring.value = true;
            retry_feedback.value = "";
            transfer_progress.phase = "Preparing";
            transfer_progress.current_chunk = 0;
            transfer_progress.total_chunks = 0;
            transfer_progress.current_round = 0;
            transfer_progress.total_rounds = 0;
            transfer_progress.sent_packets = 0;
            transfer_progress.expected_packets = 0;
            await nextTick();
            fit_qr_to_viewport(true);

            try {
              const file_buffer = await file.arrayBuffer();
              const original_bytes = new Uint8Array(file_buffer);
              const file_sha256 = await sha256_hex(original_bytes);

              const compressed_data = pako.gzip(file_buffer, {
                level: runtime_config.compression_level,
              });
              const session_id = Date.now().toString(36);
              let transfer_file_name = file.name;
              const sender_profile = build_sender_profile(runtime_config);

              let chunk_size_target = runtime_config.initial_chunk_size;
              let chunk_size = runtime_config.initial_chunk_size;
              let total_chunks = 0;
              let metadata_packet = "";

              while (true) {
                const guarded_chunk_size = Math.max(
                  runtime_config.min_chunk_size,
                  Math.floor(chunk_size_target * runtime_config.chunk_safety_ratio)
                );
                const candidate_chunk_size = Math.min(
                  chunk_size_target,
                  guarded_chunk_size
                );
                total_chunks = Math.ceil(
                  compressed_data.length / candidate_chunk_size
                );
                metadata_packet = build_metadata_packet(
                  session_id,
                  transfer_file_name,
                  total_chunks,
                  compressed_data.length,
                  original_bytes.length,
                  file_sha256,
                  sender_profile
                );

                if (!can_fit_in_qr(metadata_packet)) {
                  if (transfer_file_name !== "transfer.bin") {
                    transfer_file_name = "transfer.bin";
                    continue;
                  }
                  throw new Error("Unable to fit transfer metadata into QR capacity");
                }

                const probe_chunk = compressed_data.subarray(
                  0,
                  Math.min(candidate_chunk_size, compressed_data.length)
                );
                const probe_packet = build_data_packet(
                  session_id,
                  total_chunks - 1,
                  total_chunks,
                  probe_chunk,
                  crc32_bytes(probe_chunk)
                    .toString(16)
                    .toUpperCase()
                    .padStart(8, "0")
                );

                if (can_fit_in_qr(probe_packet)) {
                  chunk_size = candidate_chunk_size;
                  break;
                }

                chunk_size_target = Math.floor(chunk_size_target * 0.8);
                if (chunk_size_target < runtime_config.min_chunk_size) {
                  throw new Error(
                    "Unable to fit transfer packets into QR capacity"
                  );
                }
              }

              active_transfer = {
                session_id,
                total_chunks,
                chunk_size,
                compressed_data,
                metadata_packet,
                file_sha256,
                file_name: transfer_file_name,
                file_size: original_bytes.length,
                chunk_crc_map: {},
              };

              transfer_summary.ready = true;
              transfer_summary.session_id = session_id;
              transfer_summary.file_name = transfer_file_name;
              transfer_summary.total_chunks = total_chunks;
              transfer_summary.file_size = original_bytes.length;
              transfer_summary.file_sha256 = file_sha256;

              const initial_repeat_count = get_initial_pass_repeat_count(
                runtime_config,
                total_chunks
              );

              const all_indices = Array.from(
                { length: total_chunks },
                (_, index) => index
              );
              await send_chunk_indices(
                all_indices,
                initial_repeat_count,
                "Transferring",
                runtime_config
              );
            } catch (error) {
              is_transferring.value = false;
              transfer_progress.phase = "Failed";
              console.error(error);
              user_message.value =
                "Transfer failed. Reduce file size or move devices closer.";
            }
          };

          const retry_missing_chunks = async () => {
            if (!transfer_summary.ready || !active_transfer) {
              user_message.value = "Start a transfer before applying retry code";
              retry_feedback.value = "Start a transfer before applying retry code.";
              retry_feedback_is_error.value = true;
              return;
            }

            const runtime_config = get_sender_config();
            retry_feedback.value = "";
            retry_feedback_is_error.value = false;

            if (!retry_code_input.value) {
              user_message.value = "Paste retry code from receiver";
              retry_feedback.value = "Paste retry code from receiver.";
              retry_feedback_is_error.value = true;
              return;
            }

            try {
              const parsed = parse_retry_code(
                retry_code_input.value,
                active_transfer.total_chunks
              );
              if (parsed.session_id !== active_transfer.session_id) {
                throw create_retry_code_error(
                  "session_mismatch",
                  "Retry code is for a different session"
                );
              }

              if (parsed.total_chunks !== active_transfer.total_chunks) {
                throw create_retry_code_error(
                  "chunk_count_mismatch",
                  "Retry code chunk count does not match sender"
                );
              }

              if (!parsed.indices.length) {
                user_message.value =
                  "Receiver reports no missing chunks. Verify checksum on receiver.";
                retry_feedback.value =
                  "Code is valid. Receiver reports no missing chunks.";
                retry_feedback_is_error.value = false;
                return;
              }

              const missing_ratio =
                parsed.indices.length / active_transfer.total_chunks;
              const adjusted_runtime_config = {
                ...runtime_config,
              };
              let retry_repeat_count = runtime_config.retry_repeat_count;
              if (missing_ratio >= runtime_config.retry_high_loss_threshold) {
                adjusted_runtime_config.frame_interval_ms = Math.floor(
                  runtime_config.frame_interval_ms *
                    runtime_config.retry_high_loss_frame_multiplier
                );
                adjusted_runtime_config.start_delay_ms = Math.floor(
                  runtime_config.start_delay_ms *
                    runtime_config.retry_high_loss_start_delay_multiplier
                );
                adjusted_runtime_config.metadata_repeat_count =
                  runtime_config.metadata_repeat_count +
                  runtime_config.retry_high_loss_metadata_extra;
                retry_repeat_count += runtime_config.retry_high_loss_repeat_increment;
              }

              await send_chunk_indices(
                parsed.indices,
                retry_repeat_count,
                "Retrying",
                adjusted_runtime_config
              );
              retry_feedback.value =
                "Retry code accepted. Resending only missing chunks.";
              retry_feedback_is_error.value = false;
            } catch (error) {
              console.error(error);
              const friendly_message = format_retry_code_error(error);
              retry_feedback.value = friendly_message;
              retry_feedback_is_error.value = true;
              user_message.value = friendly_message;
            }
          };

          onMounted(() => {
            console.log("Application Initialized ...");
            fit_qr_to_viewport(true);
            watch(retry_code_input, () => {
              retry_feedback.value = "";
              retry_feedback_is_error.value = false;
            });
            watch(
              is_transferring,
              (value) => {
                set_pointer_visibility(value);
              },
              { immediate: true }
            );
            let resize_timer = null;
            window.addEventListener("resize", () => {
              if (resize_timer) {
                clearTimeout(resize_timer);
              }
              resize_timer = setTimeout(() => {
                fit_qr_to_viewport(false);
              }, 120);
            });
          });

          return {
            user_message,
            start_transfer,
            stop_transfer,
            is_transferring,
            retry_code_input,
            retry_feedback,
            retry_feedback_is_error,
            retry_missing_chunks,
            transfer_summary,
            transfer_progress,
            transfer_progress_percent,
            selected_preset,
            preset_names,
            preset_summary,
            short_checksum,
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
